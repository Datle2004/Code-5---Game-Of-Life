import pygame
import sys

class Run:    
    def __init__(self,screen):
        pygame.font.init()
        pygame.init()
        self.screen = screen
        self.cell_size = 300
        self.GREEN = (0,255,0)
        self.WHITE = (255, 255, 255)
        self.BLACK = (0, 0, 0)
        self.COUNT = 0

    # Initialize Pygame
    def draw_input(self,text, i):
        pygame.draw.rect(self.screen, (0, 0, 0), (700, i, 350, 40), 2) 
        font = pygame.font.SysFont('Arial', 25)
        text_surface = font.render(text, True, self.BLACK)
        self.screen.blit(text_surface, (700 + 5, i + 5))
        return pygame.Rect(700, i, 350, 40)
    def input_screen(self,input_text,input_rect_x,input_rect_y,check,input_active = False):
        write = ""
        # Set up fonts
        font = pygame.font.SysFont('Arial', 25)
        text_color = pygame.Color('black')

        # Set up text input
        input_rect = pygame.Rect(input_rect_x, input_rect_y, 350, 40)

        clock = pygame.time.Clock()

        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    if input_rect.collidepoint(event.pos):
                        input_active = True
                    else:
                        input_active = False
                elif event.type == pygame.KEYDOWN:
                    if input_active:
                        if event.key == pygame.K_RETURN:
                            if check:
                                return int(write)
                            else:
                                return [int(i) for i in write.split()]
                        elif event.key == pygame.K_BACKSPACE:
                            write = write[0 : -1]
                            input_text = input_text[0:-1]
                        else:
                            write += event.unicode
                            input_text += event.unicode
            pygame.draw.rect(self.screen,self.WHITE,input_rect)
            # Render the input box and text
            pygame.draw.rect(self.screen, (0, 0, 0), input_rect, 2)
            text_surface = font.render(input_text, True, text_color)
            self.screen.blit(text_surface, (input_rect.x+5, input_rect.y+5))
            
            pygame.display.update()
            clock.tick(30)
    # Function to draw the grid
    def draw_grid(self, rows, cols):
        WIDTH = self.cell_size * cols
        HEIGHT = self.cell_size * rows
        for row in range(rows):
            for col in range(cols):
                pygame.draw.rect(self.screen, self.WHITE, (col * self.cell_size, row * self.cell_size, self.cell_size, self.cell_size))
        for x in range(0,WIDTH+self.cell_size,self.cell_size):
            line_start = (x,0)
            line_end = (x,HEIGHT)
            pygame.draw.line(self.screen,self.GREEN,line_start,line_end,2)
        for y in range(0,HEIGHT+self.cell_size,self.cell_size):
            line_start = (0,y)
            line_end = (WIDTH,y)
            pygame.draw.line(self.screen,self.GREEN,line_start,line_end,2)

    # Function to update the grid based on user clicks
    def update_grid(self,grid, mouse_pos):
        col = mouse_pos[0] // self.cell_size
        row = mouse_pos[1] // self.cell_size
        grid[row][col] = 1 - grid[row][col]

    # Function to calculate the next generation of cells
    def next_generation(self,curr_gen,live_cell,dead_cell):
        new_gen = [[0] * len(curr_gen[0]) for _ in range(len(curr_gen))]
        
        for i in range(len(curr_gen)):
            for j in range(len(curr_gen[0])):
                neighbors = sum(curr_gen[i + x][j + y] for x in [-1, 0, 1] for y in [-1, 0, 1]
                                if 0 <= i + x < len(curr_gen) and 0 <= j + y < len(curr_gen[0]) and (x != 0 or y != 0))
                
                if curr_gen[i][j] == 1:
                    new_gen[i][j] = 1 if neighbors in live_cell else 0
                else:
                    new_gen[i][j] = 1 if neighbors in dead_cell else 0
        
        return new_gen

    # Function to draw the cells on the grid
    def draw_cells(self, grid):
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == 1:
                    pygame.draw.rect(self.screen, self.BLACK, (col * self.cell_size + 2, row * self.cell_size + 2, self.cell_size - 2, self.cell_size - 2))
    def draw_pause_button(self, paused,start,button_rect):
        pygame.draw.rect(self.screen, (255, 0, 0), button_rect)
        font = pygame.font.SysFont('Arial', 24)
        text = font.render("Pause" if not paused or not start else "Continue", True, self.BLACK)
        text_w = text.get_width()
        self.screen.blit(text, (250 + (100 - text_w)//2, button_rect.y + 10))
    
    def draw_reset_button(self, reset_button):
        pygame.draw.rect(self.screen, (0, 0, 255), reset_button)
        font = pygame.font.SysFont('Arial', 24)
        text = font.render('Reset', True, self.BLACK)
        text_w = text.get_width()
        self.screen.blit(text, ((100-text_w)//2 + 415, reset_button.y + 10))

    def draw_generation(self,check):
        if check:
            self.COUNT +=1
        print(self.COUNT)
       
        font = pygame.font.SysFont('Arial',24)
        text = font.render(f"Generation: {self.COUNT}",True,self.BLACK)
        text_w = text.get_width()
        pygame.draw.rect(self.screen,(0,0,255),(50,700,165,50))
        self.screen.blit(text,(50 + (165 - text_w)//2,710))

    # Main function
    def main(self):
        rows_pos = self.draw_input("Rows: ",50)
        cols_pos = self.draw_input("Cols: ",100)
        live_cell_pos = self.draw_input("Live Cell: ",150)
        dead_cell_pos = self.draw_input("Dead Cell: ",200)
        speed_pos = self.draw_input("Speed: ",250)

        button_rect = pygame.Rect(250,700,100,50)
        reset_button = pygame.Rect(415,700,100,50)
        # Create the grid
        rows,cols = (2,2)
        grid = [[0] * cols for _ in range(rows)]
        live_cell = [2,3]
        dead_cell = [3]
        speed = 20

        # Main loop
        running = True
        pause = False
        start = False
        check = False
        clock = pygame.time.Clock()
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    if not button_rect.collidepoint(event.pos): 
                        if rows_pos.collidepoint(event.pos):
                            rows = self.input_screen("Rows: ",700,50,True,True)
                            self.cell_size = 600 // max(rows,cols)
                            pygame.draw.rect(self.screen,self.WHITE,(0,0,602,602))
                            grid = [[0] * cols for _ in range(rows)]
                            self.COUNT = 0
                        elif cols_pos.collidepoint(event.pos):
                            cols = self.input_screen("Cols: ",700,100,True,True)
                            self.cell_size = 600 // max(rows,cols)
                            pygame.draw.rect(self.screen,self.WHITE,(0,0,602,602))
                            grid = [[0] * cols for _ in range(rows)]
                            self.COUNT =0 
                        elif live_cell_pos.collidepoint(event.pos):
                            live_cell = self.input_screen("Live Cell: ",700,150,False,True)
                            self.COUNT = 0
                        elif dead_cell_pos.collidepoint(event.pos):
                            dead_cell = self.input_screen("Dead Cell: ",700,200,False,True)
                            self.COUNT = 0
                        elif speed_pos.collidepoint(event.pos):
                            speed = self.input_screen("Speed: ",700,250,True,True)
                            self.COUNT = 0
                        elif reset_button.collidepoint(event.pos):
                            grid = [[0] * cols for _ in range(rows)]
                            self.COUNT = 0
                            self.draw_generation(False)
                        elif pygame.Rect((0,0,cols*self.cell_size,rows*self.cell_size)).collidepoint(event.pos):
                            self.update_grid(grid, pygame.mouse.get_pos())
                            pause = True
                            start = False
                            self.COUNT = 0
                            self.draw_generation(False)
                        else:
                            pass
                    else:
                        pause = not pause
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_RETURN:
                        start = True
                        pause = False


            # Draw the grid and cells
            self.draw_grid(rows, cols)
            self.draw_cells(grid)
            
            self.draw_pause_button(pause,start,button_rect)
            self.draw_reset_button(reset_button)
            if not pause and start:
                self.draw_generation(check)
                grid = self.next_generation(grid,live_cell,dead_cell)
            if grid == self.next_generation(grid,live_cell,dead_cell):
                check = False
            else:
                check = True

            # Update the display
            pygame.display.update()
            clock.tick(speed)

        # Quit Pygame
        pygame.quit()
        sys.exit()
